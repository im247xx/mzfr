<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>3D迷路 - モバイル対応版</title>
    <script src="https://cdn.jsdelivr.net/npm/three@0.167.1/build/three.min.js"></script>
    <style>
        body { margin: 0; overflow: hidden; background: #000; touch-action: none; }
        canvas { display: block; }
        #info {
            position: absolute;
            top: 10px; left: 10px; right: 10px;
            color: white;
            font-family: Arial, sans-serif;
            background: rgba(0,0,0,0.6);
            padding: 10px;
            border-radius: 10px;
            font-size: 14px;
            text-align: center;
            pointer-events: none;
            z-index: 10;
        }
        #joystick {
            position: absolute;
            bottom: 30px;
            left: 30px;
            width: 120px;
            height: 120px;
            background: rgba(255,255,255,0.1);
            border-radius: 50%;
            border: 3px solid rgba(255,255,255,0.3);
            display: none;
            z-index: 20;
        }
        #knob {
            position: absolute;
            width: 50px;
            height: 50px;
            background: rgba(0,255,136,0.8);
            border-radius: 50%;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            box-shadow: 0 0 20px #00ff88;
        }
        #win {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            color: #0f0;
            font-size: 50px;
            font-weight: bold;
            text-shadow: 0 0 30px #0f0;
            display: none;
            text-align: center;
            pointer-events: none;
        }
    </style>
</head>
<body>
    <div id="info">
        <span id="mobileInfo">指でジョイスティックを操作</span>
        <span id="pcInfo">WASD/矢印キー: 移動 | マウス: 視点 | クリックでロック</span>
    </div>
    <div id="joystick">
        <div id="knob"></div>
    </div>
    <div id="win">クリアおめでとう！<br><small>リロードで再挑戦</small></div>

    <script>
        // モバイル検知
        const isMobile = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
        document.getElementById('mobileInfo').style.display = isMobile ? 'block' : 'none';
        document.getElementById('pcInfo').style.display = isMobile ? 'none' : 'block';
        if (isMobile) document.getElementById('joystick').style.display = 'block';

        // Three.js設定
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87ceeb);
        scene.fog = new THREE.FogExp2(0x87ceeb, 0.015);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);

        const light = new THREE.DirectionalLight(0xffffff, 1);
        light.position.set(10, 20, 10);
        light.castShadow = true;
        scene.add(light);
        scene.add(new THREE.AmbientLight(0x666666));

        // 地面
        const floor = new THREE.Mesh(
            new THREE.PlaneGeometry(50, 50),
            new THREE.MeshStandardMaterial({ color: 0x228B22 })
        );
        floor.rotation.x = -Math.PI / 2;
        floor.receiveShadow = true;
        scene.add(floor);

        // 壁マテリアル
        const wallMaterial = new THREE.MeshStandardMaterial({ color: 0x4444aa });

        // 迷路データ (10x10)
        const maze = [
            [1,1,1,1,1,1,1,1,1,1],
            [1,0,0,0,1,0,0,0,0,1],
            [1,0,1,0,1,0,1,1,0,1],
            [1,0,1,0,0,0,0,1,0,1],
            [1,0,1,1,1,1,0,1,0,1],
            [1,0,0,0,0,0,0,0,0,1],
            [1,1,1,0,1,1,1,1,0,1],
            [1,0,0,0,0,0,0,0,0,1],
            [1,0,1,1,1,1,1,1,0,1],
            [1,1,1,1,1,1,1,1,1,1]
        ];

        const wallSize = 5;
        for (let i = 0; i < maze.length; i++) {
            for (let j = 0; j < maze[i].length; j++) {
                if (maze[i][j] === 1) {
                    const wall = new THREE.Mesh(
                        new THREE.BoxGeometry(wallSize, wallSize * 2, wallSize),
                        wallMaterial
                    );
                    wall.position.set(j * wallSize - 25, wallSize, i * wallSize - 25);
                    wall.castShadow = true;
                    wall.receiveShadow = true;
                    scene.add(wall);
                }
            }
        }

        // ゴール（赤い柱）
        const goal = new THREE.Mesh(
            new THREE.BoxGeometry(3, 8, 3),
            new THREE.MeshStandardMaterial({ color: 0xff0000, emissive: 0xff2222, emissiveIntensity: 0.8 })
        );
        goal.position.set(35, 4, 35);
        scene.add(goal);

        // プレイヤー初期位置
        camera.position.set(2.5, 5, 12.5);

        // 移動方向
        let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false;

        // PC用キー操作
        if (!isMobile) {
            document.addEventListener('keydown', e => {
                switch (e.key.toLowerCase()) {
                    case 'w': case 'arrowup': moveForward = true; break;
                    case 's': case 'arrowdown': moveBackward = true; break;
                    case 'a': case 'arrowleft': moveLeft = true; break;
                    case 'd': case 'arrowright': moveRight = true; break;
                }
            });
            document.addEventListener('keyup', e => {
                switch (e.key.toLowerCase()) {
                    case 'w': case 'arrowup': moveForward = false; break;
                    case 's': case 'arrowdown': moveBackward = false; break;
                    case 'a': case 'arrowleft': moveLeft = false; break;
                    case 'd': case 'arrowright': moveRight = false; break;
                }
            });

            // マウスロック（PC用）
            renderer.domElement.addEventListener('click', () => renderer.domElement.requestPointerLock());
            let yaw = 0, pitch = 0;
            document.addEventListener('mousemove', e => {
                if (document.pointerLockElement === renderer.domElement) {
                    yaw -= e.movementX * 0.002;
                    pitch -= e.movementY * 0.002;
                    pitch = Math.max(-Math.PI/2 + 0.1, Math.min(Math.PI/2 - 0.1, pitch));
                    camera.rotation.y = yaw;
                    camera.rotation.x = pitch;
                }
            });
        }

        // モバイル用ジョイスティック
        if (isMobile) {
            const joystick = document.getElementById('joystick');
            const knob = document.getElementById('knob');
            let touchId = null;
            let centerX, centerY;

            joystick.addEventListener('touchstart', e => {
                e.preventDefault();
                if (touchId === null) {
                    const touch = e.touches[0];
                    touchId = touch.identifier;
                    centerX = joystick.offsetLeft + joystick.offsetWidth / 2;
                    centerY = joystick.offsetTop + joystick.offsetHeight / 2;
                }
            });

            joystick.addEventListener('touchmove', e => {
                e.preventDefault();
                for (let touch of e.touches) {
                    if (touch.identifier === touchId) {
                        const dx = touch.clientX - centerX;
                        const dy = touch.clientY - centerY;
                        const dist = Math.min(50, Math.hypot(dx, dy));
                        const angle = Math.atan2(dx, dy);

                        knob.style.transform = `translate(${dist * Math.cos(angle)}px, ${dist * Math.sin(angle)}px)`;

                        // 移動方向判定
                        moveForward = dy < -20;
                        moveBackward = dy > 20;
                        moveLeft = dx < -20;
                        moveRight = dx > 20;
                    }
                }
            });

            joystick.addEventListener('touchend', e => {
                e.preventDefault();
                if (e.touches.length === 0 || !Array.from(e.touches).some(t => t.identifier === touchId)) {
                    touchId = null;
                    knob.style.transform = 'translate(-50%, -50%)';
                    moveForward = moveBackward = moveLeft = moveRight = false;
                }
            });
        }

        // 衝突検知
        function canMoveTo(x, z) {
            const gridX = Math.floor((x + 25) / wallSize);
            const gridZ = Math.floor((z + 25) / wallSize);
            if (gridX < 0 || gridX >= 10 || gridZ < 0 || gridZ >= 10) return false;
            return maze[gridZ][gridX] === 0;
        }

        // アニメーション
        function animate() {
            requestAnimationFrame(animate);

            const speed = 0.2;
            let dx = 0, dz = 0;

            if (moveForward) { dx -= Math.sin(camera.rotation.y) * speed; dz -= Math.cos(camera.rotation.y) * speed; }
            if (moveBackward) { dx += Math.sin(camera.rotation.y) * speed; dz += Math.cos(camera.rotation.y) * speed; }
            if (moveLeft) { dx -= Math.cos(camera.rotation.y) * speed; dz += Math.sin(camera.rotation.y) * speed; }
            if (moveRight) { dx += Math.cos(camera.rotation.y) * speed; dz -= Math.sin(camera.rotation.y) * speed; }

            const newX = camera.position.x + dx;
            const newZ = camera.position.z + dz;

            if (canMoveTo(newX, newZ)) {
                camera.position.x = newX;
                camera.position.z = newZ;
            }

            // ゴール判定
            if (camera.position.distanceTo(goal.position) < 5) {
                document.getElementById('win').style.display = 'block';
            }

            renderer.render(scene, camera);
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();
    </script>
</body>
</html>
